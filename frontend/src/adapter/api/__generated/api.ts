/* tslint:disable */
/* eslint-disable */
/**
 * melodyMingle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof Event
     */
    'creator': User;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'eventType': EventEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'startDate': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'endDate': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * bytea blob
     * @type {File}
     * @memberof Event
     */
    'image'?: File;
    /**
     * 
     * @type {Array<User>}
     * @memberof Event
     */
    'participants'?: Array<User>;
}

export const EventEventTypeEnum = {
    Concert: 'Concert',
    Party: 'Party',
    Festival: 'Festival'
} as const;

export type EventEventTypeEnum = typeof EventEventTypeEnum[keyof typeof EventEventTypeEnum];

/**
 * 
 * @export
 * @interface GetAuthSpotifyCallback400Response
 */
export interface GetAuthSpotifyCallback400Response {
    /**
     * 
     * @type {string}
     * @memberof GetAuthSpotifyCallback400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetMatches2XXResponse
 */
export interface GetMatches2XXResponse {
    /**
     * 
     * @type {Match}
     * @memberof GetMatches2XXResponse
     */
    'match1'?: Match;
    /**
     * 
     * @type {Match}
     * @memberof GetMatches2XXResponse
     */
    'match2'?: Match;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id': string;
    /**
     * 
     * @type {User}
     * @memberof Group
     */
    'creator'?: User;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * bytea blob
     * @type {File}
     * @memberof Group
     */
    'image'?: File;
    /**
     * 
     * @type {Array<User>}
     * @memberof Group
     */
    'members'?: Array<User>;
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {User}
     * @memberof Match
     */
    'userA': User;
    /**
     * 
     * @type {User}
     * @memberof Match
     */
    'userB': User;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'matchDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Match
     */
    'result'?: boolean;
}
/**
 * 
 * @export
 * @interface PostAuthLogin200Response
 */
export interface PostAuthLogin200Response {
    /**
     * 
     * @type {string}
     * @memberof PostAuthLogin200Response
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthLoginRequest
 */
export interface PostAuthLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof PostAuthLoginRequest
     */
    'eMail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthLoginRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthRegister2XXResponseInner
 */
export interface PostAuthRegister2XXResponseInner {
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister2XXResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister2XXResponseInner
     */
    'eMail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister2XXResponseInner
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister2XXResponseInner
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister2XXResponseInner
     */
    'passwordHash'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthRegister400Response
 */
export interface PostAuthRegister400Response {
    /**
     * 
     * @type {Array<PostAuthRegister400ResponseErrorsInner>}
     * @memberof PostAuthRegister400Response
     */
    'errors'?: Array<PostAuthRegister400ResponseErrorsInner>;
}
/**
 * 
 * @export
 * @interface PostAuthRegister400ResponseErrorsInner
 */
export interface PostAuthRegister400ResponseErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'minimum'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'inclusive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'exact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostAuthRegister400ResponseErrorsInner
     */
    'path'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PostAuthRegisterRequest
 */
export interface PostAuthRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegisterRequest
     */
    'eMail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegisterRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegisterRequest
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostAuthRegisterRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface PostUserRequest
 */
export interface PostUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PostUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof PostUserRequest
     */
    'dateOfBirth': string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'genre': string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    'artist'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the given user.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'dateOfBirth': string;
    /**
     * The date that the user was created.
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * unique
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'state'?: string;
    /**
     * bytea blob
     * @type {File}
     * @memberof User
     */
    'image'?: File;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'passwordHash': string;
    /**
     * The music genres the user likes.
     * @type {Array<string>}
     * @memberof User
     */
    'genrePreferences'?: Array<string>;
    /**
     * 
     * @type {Array<Song>}
     * @memberof User
     */
    'favoriteSongs'?: Array<Song>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'gender'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventsEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventsEventId', 'eventId', eventId)
            const localVarPath = `/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsGroupId: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupsGroupId', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a match
         * @param {string} [userA] id of user A
         * @param {string} [userB] id of user B
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMatches: async (userA?: string, userB?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userA !== undefined) {
                localVarQueryParameter['userA'] = userA;
            }

            if (userB !== undefined) {
                localVarQueryParameter['userB'] = userB;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSongsSongId: async (songId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            assertParamExists('deleteSongsSongId', 'songId', songId)
            const localVarPath = `/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete User by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId: async (userId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUsersUserId', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Constructing spotify authorization url
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthSpotifyAuthorize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthSpotifyCallback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/spotify/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventsEventId', 'eventId', eventId)
            const localVarPath = `/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsGroupId: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupsGroupId', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check wether users have matched each other
         * @param {string} userA id of user A
         * @param {string} [userB] id of user B
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches: async (userA: string, userB?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userA' is not null or undefined
            assertParamExists('getMatches', 'userA', userA)
            const localVarPath = `/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userA !== undefined) {
                localVarQueryParameter['userA'] = userA;
            }

            if (userB !== undefined) {
                localVarQueryParameter['userB'] = userB;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all songs
         * @param {string} [name] If provided, filter returned songs by name.
         * @param {string} [artist] If provided, filter returned songs by artist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongs: async (name?: string, artist?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/songs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (artist !== undefined) {
                localVarQueryParameter['artist'] = artist;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongsSongId: async (songId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            assertParamExists('getSongsSongId', 'songId', songId)
            const localVarPath = `/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get User Info by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId: async (userId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersUserId', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login a user with credentials
         * @param {PostAuthLoginRequest} [postAuthLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogin: async (postAuthLoginRequest?: PostAuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {PostAuthRegisterRequest} [postAuthRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthRegister: async (postAuthRegisterRequest?: PostAuthRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAuthRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMatches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new song
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSongs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/songs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user.
         * @summary Create New User
         * @param {PostUserRequest} [postUserRequest] Post the necessary fields for the API to create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser: async (postUserRequest?: PostUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putEventsEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('putEventsEventId', 'eventId', eventId)
            const localVarPath = `/events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGroupsGroupId: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('putGroupsGroupId', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSongsSongId: async (songId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            assertParamExists('putSongsSongId', 'songId', songId)
            const localVarPath = `/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId: async (userId: string, authorization?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('putUsersUserId', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventsEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventsEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteEventsEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupsGroupId(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupsGroupId(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteGroupsGroupId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a match
         * @param {string} [userA] id of user A
         * @param {string} [userB] id of user B
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMatches(userA?: string, userB?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMatches(userA, userB, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSongsSongId(songId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSongsSongId(songId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteSongsSongId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete User by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersUserId(userId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersUserId(userId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteUsersUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Constructing spotify authorization url
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthSpotifyAuthorize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthSpotifyAuthorize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAuthSpotifyAuthorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthSpotifyCallback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthSpotifyCallback(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAuthSpotifyCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getEventsEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupsGroupId(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupsGroupId(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGroupsGroupId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check wether users have matched each other
         * @param {string} userA id of user A
         * @param {string} [userB] id of user B
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatches(userA: string, userB?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMatches2XXResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatches(userA, userB, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all songs
         * @param {string} [name] If provided, filter returned songs by name.
         * @param {string} [artist] If provided, filter returned songs by artist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongs(name?: string, artist?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSongs(name, artist, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongsSongId(songId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSongsSongId(songId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSongsSongId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get User Info by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserId(userId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserId(userId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getUsersUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login a user with credentials
         * @param {PostAuthLoginRequest} [postAuthLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthLogin(postAuthLoginRequest?: PostAuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthLogin(postAuthLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new user
         * @param {PostAuthRegisterRequest} [postAuthRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthRegister(postAuthRegisterRequest?: PostAuthRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostAuthRegister2XXResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthRegister(postAuthRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postAuthRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMatches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMatches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new song
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSongs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSongs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postSongs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user.
         * @summary Create New User
         * @param {PostUserRequest} [postUserRequest] Post the necessary fields for the API to create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUser(postUserRequest?: PostUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUser(postUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putEventsEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putEventsEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putEventsEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putGroupsGroupId(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putGroupsGroupId(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putGroupsGroupId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSongsSongId(songId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSongsSongId(songId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putSongsSongId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update User by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersUserId(userId: string, authorization?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersUserId(userId, authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.putUsersUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventsEventId(eventId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventsEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupsGroupId(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupsGroupId(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a match
         * @param {string} [userA] id of user A
         * @param {string} [userB] id of user B
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMatches(userA?: string, userB?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMatches(userA, userB, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSongsSongId(songId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSongsSongId(songId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete User by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId(userId: string, authorization?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersUserId(userId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Constructing spotify authorization url
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthSpotifyAuthorize(options?: any): AxiosPromise<void> {
            return localVarFp.getAuthSpotifyAuthorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Your GET endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthSpotifyCallback(options?: any): AxiosPromise<void> {
            return localVarFp.getAuthSpotifyCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any): AxiosPromise<void> {
            return localVarFp.getEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific event by ID
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsEventId(eventId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getEventsEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any): AxiosPromise<void> {
            return localVarFp.getGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific group by ID
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsGroupId(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getGroupsGroupId(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check wether users have matched each other
         * @param {string} userA id of user A
         * @param {string} [userB] id of user B
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(userA: string, userB?: string, options?: any): AxiosPromise<GetMatches2XXResponse> {
            return localVarFp.getMatches(userA, userB, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all songs
         * @param {string} [name] If provided, filter returned songs by name.
         * @param {string} [artist] If provided, filter returned songs by artist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongs(name?: string, artist?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getSongs(name, artist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongsSongId(songId: string, options?: any): AxiosPromise<Song> {
            return localVarFp.getSongsSongId(songId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get User Info by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId(userId: string, authorization?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUsersUserId(userId, authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login a user with credentials
         * @param {PostAuthLoginRequest} [postAuthLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogin(postAuthLoginRequest?: PostAuthLoginRequest, options?: any): AxiosPromise<PostAuthLogin200Response> {
            return localVarFp.postAuthLogin(postAuthLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {PostAuthRegisterRequest} [postAuthRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthRegister(postAuthRegisterRequest?: PostAuthRegisterRequest, options?: any): AxiosPromise<Array<PostAuthRegister2XXResponseInner>> {
            return localVarFp.postAuthRegister(postAuthRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEvents(options?: any): AxiosPromise<void> {
            return localVarFp.postEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(options?: any): AxiosPromise<void> {
            return localVarFp.postGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMatches(options?: any): AxiosPromise<void> {
            return localVarFp.postMatches(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new song
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSongs(options?: any): AxiosPromise<void> {
            return localVarFp.postSongs(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user.
         * @summary Create New User
         * @param {PostUserRequest} [postUserRequest] Post the necessary fields for the API to create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUser(postUserRequest?: PostUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.postUser(postUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putEventsEventId(eventId: string, options?: any): AxiosPromise<void> {
            return localVarFp.putEventsEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGroupsGroupId(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.putGroupsGroupId(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing song by ID
         * @param {string} songId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSongsSongId(songId: string, options?: any): AxiosPromise<void> {
            return localVarFp.putSongsSongId(songId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update User by User ID
         * @param {string} userId 
         * @param {string} [authorization] access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId(userId: string, authorization?: string, options?: any): AxiosPromise<void> {
            return localVarFp.putUsersUserId(userId, authorization, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Delete an event by ID
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteEventsEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteEventsEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a group by ID
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteGroupsGroupId(groupId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteGroupsGroupId(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a match
     * @param {string} [userA] id of user A
     * @param {string} [userB] id of user B
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteMatches(userA?: string, userB?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteMatches(userA, userB, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a song by ID
     * @param {string} songId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteSongsSongId(songId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteSongsSongId(songId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete User by User ID
     * @param {string} userId 
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUsersUserId(userId: string, authorization?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUsersUserId(userId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Constructing spotify authorization url
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAuthSpotifyAuthorize(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAuthSpotifyAuthorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Your GET endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAuthSpotifyCallback(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAuthSpotifyCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEvents(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific event by ID
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEventsEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEventsEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroups(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific group by ID
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGroupsGroupId(groupId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGroupsGroupId(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check wether users have matched each other
     * @param {string} userA id of user A
     * @param {string} [userB] id of user B
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMatches(userA: string, userB?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMatches(userA, userB, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all songs
     * @param {string} [name] If provided, filter returned songs by name.
     * @param {string} [artist] If provided, filter returned songs by artist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSongs(name?: string, artist?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSongs(name, artist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a song by ID
     * @param {string} songId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSongsSongId(songId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSongsSongId(songId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of the user with the matching user ID.
     * @summary Get User Info by User ID
     * @param {string} userId 
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsersUserId(userId: string, authorization?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUsersUserId(userId, authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login a user with credentials
     * @param {PostAuthLoginRequest} [postAuthLoginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAuthLogin(postAuthLoginRequest?: PostAuthLoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postAuthLogin(postAuthLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {PostAuthRegisterRequest} [postAuthRegisterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postAuthRegister(postAuthRegisterRequest?: PostAuthRegisterRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postAuthRegister(postAuthRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postEvents(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postGroups(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postMatches(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postMatches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new song
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postSongs(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postSongs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user.
     * @summary Create New User
     * @param {PostUserRequest} [postUserRequest] Post the necessary fields for the API to create a new user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postUser(postUserRequest?: PostUserRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postUser(postUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific event
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putEventsEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putEventsEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putGroupsGroupId(groupId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putGroupsGroupId(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing song by ID
     * @param {string} songId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putSongsSongId(songId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putSongsSongId(songId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update User by User ID
     * @param {string} userId 
     * @param {string} [authorization] access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putUsersUserId(userId: string, authorization?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).putUsersUserId(userId, authorization, options).then((request) => request(this.axios, this.basePath));
    }
}



